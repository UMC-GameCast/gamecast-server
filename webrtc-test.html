<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🎮 GameCast WebRTC 고급 테스트</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 40px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        .section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 12px;
            border: 1px solid #e9ecef;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
        }
        .section h3 {
            margin-top: 0;
            color: #495057;
            font-size: 1.4em;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        .form-group {
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #495057;
        }
        input, select {
            width: 100%;
            padding: 12px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s, box-shadow 0.3s;
        }
        input:focus, select:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0,123,255,0.25);
        }
        button {
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 10px;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,123,255,0.4);
        }
        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .status {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 600;
            text-align: center;
            font-size: 16px;
        }
        .status.connected {
            background: linear-gradient(135deg, #d4edda, #c3e6cb);
            color: #155724;
            border: 2px solid #28a745;
        }
        .status.disconnected {
            background: linear-gradient(135deg, #f8d7da, #f5c6cb);
            color: #721c24;
            border: 2px solid #dc3545;
        }
        .status.waiting {
            background: linear-gradient(135deg, #fff3cd, #ffeaa7);
            color: #856404;
            border: 2px solid #ffc107;
        }
        #log {
            background: #2d3748;
            color: #e2e8f0;
            border: 2px solid #4a5568;
            padding: 20px;
            border-radius: 8px;
            height: 300px;
            overflow-y: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            line-height: 1.4;
        }
        .video-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .video-box {
            background: #2d3748;
            border-radius: 12px;
            padding: 15px;
            text-align: center;
        }
        .video-box h4 {
            color: white;
            margin: 0 0 15px 0;
            font-size: 1.1em;
        }
        video {
            width: 100%;
            height: 200px;
            background: #1a202c;
            border-radius: 8px;
            border: 2px solid #4a5568;
        }
        .room-info {
            background: linear-gradient(135deg, #e7f3ff, #cce7ff);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            border: 2px solid #007bff;
        }
        .participants {
            background: linear-gradient(135deg, #f0f8f0, #e6f3e6);
            padding: 20px;
            border-radius: 12px;
            border: 2px solid #28a745;
        }
        .participant {
            padding: 12px;
            margin: 10px 0;
            background: white;
            border-radius: 8px;
            border-left: 4px solid #28a745;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .audio-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin: 15px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .volume-control {
            flex: 1;
        }
        .connection-quality {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin: 20px 0;
        }
        .quality-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid #dee2e6;
        }
        .quality-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #007bff;
        }
        .quick-actions {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border: 1px solid #f5c6cb;
        }
        .success-message {
            background: #d4edda;
            color: #155724;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border: 1px solid #c3e6cb;
        }
        @media (max-width: 768px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
            .video-container {
                grid-template-columns: 1fr;
            }
            .connection-quality {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🎮 GameCast WebRTC 고급 테스트</h1>
        
        <!-- 연결 상태 -->
        <div id="connectionStatus" class="status disconnected">
            🔴 서버에 연결 중...
        </div>

        <!-- 세션 정보 -->
        <div id="sessionInfo" class="status waiting" style="display: none;">
            <h4>🍪 세션 정보</h4>
            <div id="sessionDetails"></div>
            <button onclick="checkSession()" style="margin-top: 10px;">🔍 세션 확인</button>
        </div>

        <div class="main-grid">
            <!-- 1. 방 생성 섹션 -->
            <div class="section">
                <h3>📋 방 생성</h3>
                <div class="form-group">
                    <label for="roomName">방 이름:</label>
                    <input type="text" id="roomName" placeholder="멋진 방 이름" value="WebRTC 테스트 방">
                </div>
                <div class="form-group">
                    <label for="hostNickname">방장 닉네임:</label>
                    <input type="text" id="hostNickname" placeholder="방장 닉네임" value="방장">
                </div>
                <div class="form-group">
                    <label for="maxCapacity">최대 인원:</label>
                    <select id="maxCapacity">
                        <option value="2">2명</option>
                        <option value="3">3명</option>
                        <option value="4" selected>4명</option>
                        <option value="5">5명</option>
                    </select>
                </div>
                <button onclick="createRoom()" id="createRoomBtn">🏗️ 방 생성</button>
                <button onclick="getRoomList()" id="getRoomListBtn">📋 방 목록 조회</button>
            </div>

            <!-- 2. 방 참여 섹션 -->
            <div class="section">
                <h3>🚪 방 참여</h3>
                <div class="form-group">
                    <label for="joinRoomCode">방 코드:</label>
                    <input type="text" id="joinRoomCode" placeholder="6자리 코드 입력" maxlength="6" style="text-transform: uppercase;">
                </div>
                <div class="form-group">
                    <label for="guestNickname">닉네임:</label>
                    <input type="text" id="guestNickname" placeholder="게스트 닉네임" value="">
                </div>
                <div class="quick-actions">
                    <button onclick="joinRoom()" id="joinRoomBtn">🚪 방 참여</button>
                    <button onclick="leaveRoom()" disabled id="leaveBtn">🚪 방 나가기</button>
                    <button onclick="testQuickJoin()" id="quickJoinBtn">⚡ 빠른 테스트</button>
                </div>
            </div>
        </div>

        <!-- 3. 방 정보 및 참여자 -->
        <div id="roomInfo" class="room-info" style="display: none;">
            <h3>🏠 현재 방 정보</h3>
            <div id="roomDetails"></div>
            <div class="quick-actions">
                <button onclick="refreshRoomInfo()">🔄 새로고침</button>
                <button onclick="copyRoomCode()">📋 방 코드 복사</button>
            </div>
        </div>

        <div id="participantsInfo" class="participants" style="display: none;">
            <h3>👥 참여자 목록 (<span id="participantCount">0</span>명)</h3>
            <div id="participantsList"></div>
        </div>

        <!-- 4. WebRTC 미디어 테스트 -->
        <div class="section">
            <h3>🎥 WebRTC 미디어 연결</h3>
            
            <!-- 미디어 제어 -->
            <div class="audio-controls">
                <button onclick="startLocalVideo()" id="startVideoBtn">📹 비디오 시작</button>
                <button onclick="stopLocalVideo()" disabled id="stopVideoBtn">⏹️ 비디오 중지</button>
                <button onclick="toggleAudio()" id="toggleAudioBtn" disabled>🎤 음소거</button>
                <button onclick="toggleVideo()" id="toggleVideoBtn" disabled>📷 비디오 끄기</button>
                <div class="volume-control">
                    <label for="volumeSlider">음량: <span id="volumeValue">50</span>%</label>
                    <input type="range" id="volumeSlider" min="0" max="100" value="50" onchange="updateVolume()">
                </div>
            </div>

            <!-- 비디오 영역 -->
            <div class="video-container">
                <div class="video-box">
                    <h4>📹 내 화면 (로컬)</h4>
                    <video id="localVideo" autoplay muted playsinline></video>
                    <div id="localStats" class="quality-item">
                        <small>해상도: <span id="localResolution">-</span></small>
                    </div>
                </div>
                <div class="video-box">
                    <h4>📺 상대방 화면 (원격)</h4>
                    <video id="remoteVideo" autoplay playsinline></video>
                    <div id="remoteStats" class="quality-item">
                        <small>해상도: <span id="remoteResolution">-</span></small>
                    </div>
                </div>
            </div>

            <!-- WebRTC 연결 제어 -->
            <div class="quick-actions">
                <button onclick="connectToRoom()" disabled id="connectBtn">🔗 WebRTC 연결 시작</button>
                <button onclick="disconnectWebRTC()" disabled id="disconnectBtn">🔌 연결 해제</button>
                <button onclick="restartConnection()" disabled id="restartBtn">🔄 연결 재시작</button>
            </div>

            <!-- 연결 품질 정보 -->
            <div class="connection-quality">
                <div class="quality-item">
                    <div class="quality-value" id="latency">-</div>
                    <small>지연시간 (ms)</small>
                </div>
                <div class="quality-item">
                    <div class="quality-value" id="packetLoss">-</div>
                    <small>패킷 손실 (%)</small>
                </div>
                <div class="quality-item">
                    <div class="quality-value" id="bandwidth">-</div>
                    <small>대역폭 (kbps)</small>
                </div>
            </div>
        </div>

        <!-- 5. 실시간 채팅 -->
        <div class="section">
            <h3>💬 실시간 채팅</h3>
            
            <!-- 채팅 메시지 영역 -->
            <div id="chatMessages" style="height: 300px; overflow-y: auto; border: 2px solid #e9ecef; border-radius: 8px; padding: 15px; background: #f8f9fa; margin-bottom: 15px;">
                <div style="text-align: center; color: #666; padding: 20px;">
                    <p>채팅이 시작되면 여기에 메시지가 표시됩니다.</p>
                    <p><small>방에 참여한 후 채팅을 사용할 수 있습니다.</small></p>
                </div>
            </div>
            
            <!-- 채팅 입력 영역 -->
            <div style="display: flex; gap: 10px;">
                <input type="text" id="chatInput" placeholder="메시지를 입력하세요..." 
                       style="flex: 1; padding: 12px; border: 2px solid #dee2e6; border-radius: 8px;"
                       onkeypress="handleChatKeyPress(event)" disabled>
                <button onclick="sendChatMessage()" id="sendChatBtn" disabled 
                        style="min-width: 100px;">💬 전송</button>
                <button onclick="clearChat()" id="clearChatBtn">🗑️ 지우기</button>
            </div>
            
            <!-- 채팅 설정 -->
            <div style="margin-top: 15px; padding: 10px; background: #e7f3ff; border-radius: 8px; font-size: 0.9em;">
                <label style="margin-right: 20px;">
                    <input type="checkbox" id="showTimestamp" checked onchange="toggleTimestamp()"> 
                    시간 표시
                </label>
                <label style="margin-right: 20px;">
                    <input type="checkbox" id="soundNotification" checked onchange="toggleSoundNotification()"> 
                    알림음
                </label>
                <label>
                    <input type="checkbox" id="autoScroll" checked onchange="toggleAutoScroll()"> 
                    자동 스크롤
                </label>
            </div>
        </div>

        <!-- 5. 고급 테스트 기능 -->
        <div class="section">
            <h3>⚡ 고급 테스트 기능</h3>
            <div class="quick-actions">
                <button onclick="testEcho()">� 에코 테스트</button>
                <button onclick="testBandwidth()">📊 대역폭 테스트</button>
                <button onclick="simulateNetworkIssue()">🌐 네트워크 이슈 시뮬레이션</button>
                <button onclick="recordSession()">🎬 세션 녹화</button>
                <button onclick="shareScreen()">🖥️ 화면 공유</button>
            </div>
            
            <!-- 테스트 결과 -->
            <div id="testResults" style="display: none;" class="success-message">
                <h4>📊 테스트 결과</h4>
                <div id="testResultContent"></div>
            </div>
        </div>

        <!-- 6. 실시간 로그 -->
        <div class="section">
            <h3>📝 실시간 로그 및 디버깅</h3>
            <div class="quick-actions">
                <button onclick="clearLog()">🗑️ 로그 지우기</button>
                <button onclick="exportLog()">💾 로그 내보내기</button>
                <button onclick="toggleDebugMode()" id="debugBtn">🐛 디버그 모드</button>
            </div>
            <div id="log"></div>
        </div>

        <!-- 7. 방 목록 -->
        <div id="roomListSection" class="section" style="display: none;">
            <h3>📋 활성 방 목록</h3>
            <div id="roomListContainer"></div>
            <button onclick="refreshRoomList()">🔄 새로고침</button>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        // 전역 변수
        let socket = null;
        let localStream = null;
        let peerConnections = new Map(); // 다중 연결 지원
        let currentRoomCode = null;
        let sessionId = null;
        let guestUserId = null;
        let isDebugMode = false;
        let connectionStats = {
            latency: 0,
            packetLoss: 0,
            bandwidth: 0
        };
        let mediaConstraints = {
            video: { width: 640, height: 480 },
            audio: true
        };

        // 채팅 관련 변수
        let chatSettings = {
            showTimestamp: true,
            soundNotification: true,
            autoScroll: true
        };
        let unreadCount = 0;

        // UUID 생성 (더 강력한 버전)
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // 향상된 로그 함수
        function log(message, type = 'info') {
            const logElement = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const colors = {
                'info': '#e2e8f0',
                'success': '#68d391',
                'error': '#fc8181',
                'warning': '#f6e05e',
                'debug': '#90cdf4'
            };
            
            const coloredMessage = `<span style="color: ${colors[type]}">[${timestamp}] ${message}</span>`;
            logElement.innerHTML += coloredMessage + '\n';
            logElement.scrollTop = logElement.scrollHeight;
            
            if (isDebugMode) {
                console.log(`[${type.toUpperCase()}] ${message}`);
            }
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
            log('로그가 지워졌습니다.', 'info');
        }

        function exportLog() {
            const logContent = document.getElementById('log').textContent;
            const blob = new Blob([logContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `webrtc-test-log-${new Date().toISOString().slice(0,19)}.txt`;
            a.click();
            URL.revokeObjectURL(url);
            log('로그를 파일로 내보냈습니다.', 'success');
        }

        function toggleDebugMode() {
            isDebugMode = !isDebugMode;
            const debugBtn = document.getElementById('debugBtn');
            debugBtn.textContent = isDebugMode ? '🐛 디버그 OFF' : '🐛 디버그 ON';
            log(`디버그 모드: ${isDebugMode ? 'ON' : 'OFF'}`, 'info');
        }

        // 에러 처리 개선
        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.textContent = `❌ ${message}`;
            document.querySelector('.container').insertBefore(errorDiv, document.querySelector('.main-grid'));
            setTimeout(() => errorDiv.remove(), 5000);
            log(message, 'error');
        }

        function showSuccess(message) {
            const successDiv = document.createElement('div');
            successDiv.className = 'success-message';
            successDiv.textContent = `✅ ${message}`;
            document.querySelector('.container').insertBefore(successDiv, document.querySelector('.main-grid'));
            setTimeout(() => successDiv.remove(), 3000);
            log(message, 'success');
        }

        // 세션 확인 함수
        async function checkSession() {
            try {
                log('🍪 세션 정보 확인 중...', 'info');
                
                // 먼저 세션 초기화
                await fetch('http://localhost:8889/init-session', {
                    method: 'GET',
                    credentials: 'include'
                });
                
                // 세션 정보 조회
                const response = await fetch('http://localhost:8889/session-info', {
                    method: 'GET',
                    credentials: 'include',
                    headers: {
                        'Accept': 'application/json'
                    }
                });

                const sessionData = await response.json();
                
                if (response.ok) {
                    displaySessionInfo(sessionData);
                    log('✅ 세션 정보 조회 성공', 'success');
                } else {
                    throw new Error('세션 정보 조회 실패');
                }
                
            } catch (error) {
                log(`❌ 세션 확인 오류: ${error.message}`, 'error');
                showError(`세션 확인 실패: ${error.message}`);
            }
        }

        function displaySessionInfo(sessionData) {
            const sessionInfoElement = document.getElementById('sessionInfo');
            const sessionDetailsElement = document.getElementById('sessionDetails');
            
            sessionDetailsElement.innerHTML = `
                <div style="text-align: left; font-size: 0.9em;">
                    <p><strong>세션 ID:</strong> <code>${sessionData.sessionID}</code></p>
                    <p><strong>인증 상태:</strong> ${sessionData.isAuthenticated ? '✅ 인증됨' : '❌ 미인증'}</p>
                    <p><strong>서버 쿠키:</strong> <code>${sessionData.cookies || '없음'}</code></p>
                    <p><strong>세션 데이터:</strong> <pre style="font-size: 0.8em; background: #f4f4f4; padding: 10px; border-radius: 4px;">${JSON.stringify(sessionData.session, null, 2)}</pre></p>
                    <p><strong>타임스탬프:</strong> ${new Date(sessionData.timestamp).toLocaleString()}</p>
                </div>
            `;
            
            sessionInfoElement.style.display = 'block';
            
            // 클라이언트 측 정보
            sessionDetailsElement.innerHTML += `
                <hr style="margin: 15px 0;">
                <p><strong>클라이언트 정보:</strong></p>
                <p><strong>User Agent:</strong> <small>${navigator.userAgent}</small></p>
                <p><strong>쿠키 정책:</strong> ${navigator.cookieEnabled ? '✅ 활성화' : '❌ 비활성화'}</p>
                <p><strong>HTTPS:</strong> ${location.protocol === 'https:' ? '✅' : '❌ (HTTP)'}</p>
            `;
        }

        // 서버 연결 (개선된 버전)
        function connectToServer() {
            log('서버 연결 시도 중...', 'info');
            
            socket = io('http://localhost:8889', {
                transports: ['websocket', 'polling'],
                timeout: 5000,
                forceNew: true
            });
            
            socket.on('connect', () => {
                log('✅ 서버에 성공적으로 연결되었습니다.', 'success');
                updateConnectionStatus(true);
                sessionId = socket.id; // Socket.IO 세션 ID 사용
            });

            socket.on('disconnect', (reason) => {
                log(`❌ 서버 연결이 끊어졌습니다. 이유: ${reason}`, 'error');
                updateConnectionStatus(false);
                resetAllConnections();
                // 채팅 기능 비활성화
                enableChatFeatures(false);
            });

            socket.on('connect_error', (error) => {
                log(`❌ 연결 오류: ${error.message}`, 'error');
                updateConnectionStatus(false);
            });

            // Socket.IO 이벤트 리스너들
            socket.on('joined-room-success', (data) => {
                log(`🎉 방 참여 성공: ${JSON.stringify(data)}`, 'success');
                currentRoomCode = data.roomCode;
                guestUserId = data.guestUserId || generateUUID();
                
                enableWebRTCControls(true);
                updateRoomInfo(data);
                showSuccess('방에 성공적으로 참여했습니다!');
            });

            socket.on('join-room-error', (data) => {
                log(`❌ 방 참여 실패: ${data.message}`, 'error');
                showError(`방 참여 실패: ${data.message}`);
            });

            socket.on('room-users', (users) => {
                log(`👥 방 참여자 업데이트: ${users.length}명`, 'info');
                updateParticipants(users);
                
                // WebRTC 연결이 활성화된 경우 다른 사용자들과 연결
                if (localStream && document.getElementById('connectBtn').disabled) {
                    users.forEach(user => {
                        if (user.socketId !== socket.id && !peerConnections.has(user.socketId)) {
                            log(`🔗 WebRTC 연결 시도: ${user.nickname}`, 'info');
                            initiateWebRTCConnection(user.socketId);
                        }
                    });
                }
            });

            socket.on('user-joined', (data) => {
                log(`👋 새 사용자 참여: ${data.nickname} (${data.socketId})`, 'info');
                // 새 사용자와 WebRTC 연결 시작
                if (localStream && data.socketId !== socket.id) {
                    setTimeout(() => {
                        initiateWebRTCConnection(data.socketId);
                    }, 1000); // 1초 후 연결 시작
                }
            });

            socket.on('user-left', (data) => {
                log(`👋 사용자 나감: ${data.nickname}`, 'info');
                closePeerConnection(data.socketId);
            });

            // 채팅 메시지 수신
            socket.on('chat-message', (data) => {
                log(`💬 채팅 메시지 수신: ${data.senderNickname}`, 'debug');
                addChatMessage(data.senderNickname, data.message, false);
            });

            // WebRTC 시그널링 이벤트들
            socket.on('offer', (data) => {
                log(`📞 Offer 수신 from ${data.fromNickname}`, 'debug');
                handleReceiveOffer(data);
            });

            socket.on('answer', (data) => {
                log(`📞 Answer 수신 from ${data.fromNickname}`, 'debug');
                handleReceiveAnswer(data);
            });

            socket.on('ice-candidate', (data) => {
                log(`🧊 ICE Candidate 수신`, 'debug');
                handleReceiveIceCandidate(data);
            });

            socket.on('error', (error) => {
                log(`❌ Socket 에러: ${error.message}`, 'error');
                showError(error.message);
            });
        }

        function updateConnectionStatus(connected) {
            const statusElement = document.getElementById('connectionStatus');
            if (connected) {
                statusElement.className = 'status connected';
                statusElement.innerHTML = '🟢 서버에 연결됨 <small>(실시간 통신 가능)</small>';
            } else {
                statusElement.className = 'status disconnected';
                statusElement.innerHTML = '🔴 서버 연결 안됨 <small>(재연결 시도 중...)</small>';
                setTimeout(() => {
                    if (!socket || !socket.connected) {
                        connectToServer();
                    }
                }, 3000); // 3초 후 재연결 시도
            }
        }

        // 방 생성 (개선된 버전)
        async function createRoom() {
            if (!sessionId) sessionId = generateUUID();
            
            const roomData = {
                roomName: document.getElementById('roomName').value || 'WebRTC 테스트 방',
                hostSessionId: sessionId,
                hostNickname: document.getElementById('hostNickname').value || '방장',
                maxCapacity: parseInt(document.getElementById('maxCapacity').value)
            };

            // 유효성 검사
            if (!roomData.roomName.trim() || !roomData.hostNickname.trim()) {
                showError('방 이름과 닉네임을 모두 입력해주세요.');
                return;
            }

            try {
                log('🏗️ 방 생성 요청 중...', 'info');
                document.getElementById('createRoomBtn').disabled = true;
                
                const response = await fetch('http://localhost:8889/api/rooms', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify(roomData)
                });

                const result = await response.json();
                
                if (result.resultType === 'SUCCESS') {
                    const roomCode = result.success.roomCode;
                    log(`✅ 방 생성 성공! 코드: ${roomCode}`, 'success');
                    
                    // UI 업데이트
                    document.getElementById('joinRoomCode').value = roomCode;
                    guestUserId = result.success.hostGuestId;
                    
                    // 자동으로 WebSocket 방 참여
                    if (socket && socket.connected) {
                        joinWebSocketRoom(roomCode, guestUserId, roomData.hostNickname);
                        // 채팅 기능 활성화
                        enableChatFeatures(true);
                    } else {
                        showError('서버에 연결되지 않았습니다. 다시 시도해주세요.');
                    }
                    
                    showSuccess(`방이 생성되었습니다! 코드: ${roomCode}`);
                } else {
                    throw new Error(result.error?.reason || '알 수 없는 오류');
                }
            } catch (error) {
                log(`❌ 방 생성 오류: ${error.message}`, 'error');
                showError(`방 생성 실패: ${error.message}`);
            } finally {
                document.getElementById('createRoomBtn').disabled = false;
            }
        }

        // 방 참여 (개선된 버전)
        async function joinRoom() {
            const roomCode = document.getElementById('joinRoomCode').value.trim().toUpperCase();
            const nickname = document.getElementById('guestNickname').value.trim();
            
            if (!roomCode) {
                showError('방 코드를 입력해주세요.');
                return;
            }
            
            if (!nickname) {
                showError('닉네임을 입력해주세요.');
                return;
            }

            if (!sessionId) sessionId = generateUUID();
            
            const joinData = {
                roomCode: roomCode,
                nickname: nickname
            };

            try {
                log('🚪 방 참여 요청 중...', 'info');
                document.getElementById('joinRoomBtn').disabled = true;
                
                const response = await fetch('http://localhost:8889/api/rooms/join', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify(joinData)
                });

                const result = await response.json();
                
                if (result.resultType === 'SUCCESS') {
                    log(`✅ 방 참여 성공!`, 'success');
                    guestUserId = result.success.guestUserId;
                    
                    // WebSocket 방 참여
                    if (socket && socket.connected) {
                        joinWebSocketRoom(roomCode, guestUserId, nickname);
                        // 채팅 기능 활성화
                        enableChatFeatures(true);
                    } else {
                        showError('서버에 연결되지 않았습니다.');
                    }
                } else {
                    throw new Error(result.error?.reason || '알 수 없는 오류');
                }
            } catch (error) {
                log(`❌ 방 참여 오류: ${error.message}`, 'error');
                showError(`방 참여 실패: ${error.message}`);
            } finally {
                document.getElementById('joinRoomBtn').disabled = false;
            }
        }

        // WebSocket 방 참여
        function joinWebSocketRoom(roomCode, guestUserId, nickname) {
            if (!socket || !socket.connected) {
                showError('서버에 연결되지 않았습니다.');
                return;
            }

            socket.emit('join-room', {
                roomCode: roomCode,
                guestUserId: guestUserId,
                nickname: nickname
            });

            log(`🔌 WebSocket 방 참여 요청: ${roomCode}`, 'info');
        }

        // 방 나가기
        function leaveRoom() {
            if (socket && currentRoomCode) {
                socket.emit('leave-room');
                log('🚪 방을 나갔습니다.', 'info');
                
                resetRoomState();
                showSuccess('방에서 나왔습니다.');
            }
        }

        function resetRoomState() {
            currentRoomCode = null;
            guestUserId = null;
            enableWebRTCControls(false);
            hideRoomInfo();
            resetAllConnections();
        }

        // 빠른 테스트 함수
        function testQuickJoin() {
            // 현재 생성된 방이 있으면 자동으로 참여
            const roomCode = document.getElementById('joinRoomCode').value;
            if (roomCode) {
                document.getElementById('guestNickname').value = `테스터${Math.floor(Math.random() * 1000)}`;
                joinRoom();
            } else {
                showError('먼저 방을 생성하거나 방 코드를 입력해주세요.');
            }
        }

        // 향상된 비디오 함수들
        async function startLocalVideo() {
            try {
                log('📹 미디어 접근 권한 요청 중...', 'info');
                
                localStream = await navigator.mediaDevices.getUserMedia(mediaConstraints);
                
                const localVideo = document.getElementById('localVideo');
                localVideo.srcObject = localStream;
                
                // 해상도 정보 업데이트
                const videoTrack = localStream.getVideoTracks()[0];
                if (videoTrack) {
                    const settings = videoTrack.getSettings();
                    document.getElementById('localResolution').textContent = 
                        `${settings.width}x${settings.height}`;
                }
                
                updateMediaControls(true);
                log('✅ 로컬 미디어 스트림이 시작되었습니다.', 'success');
                
                // WebRTC 연결 버튼 활성화 (방에 참여한 경우)
                if (currentRoomCode) {
                    document.getElementById('connectBtn').disabled = false;
                }
                
            } catch (error) {
                log(`❌ 미디어 접근 실패: ${error.message}`, 'error');
                showError(`미디어 접근 실패: ${error.message}`);
            }
        }

        function stopLocalVideo() {
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    track.stop();
                    log(`트랙 중지: ${track.kind}`, 'debug');
                });
                localStream = null;
                
                document.getElementById('localVideo').srcObject = null;
                document.getElementById('localResolution').textContent = '-';
                
                updateMediaControls(false);
                log('⏹️ 로컬 미디어 스트림이 중지되었습니다.', 'info');
                
                // 모든 WebRTC 연결 해제
                resetAllConnections();
            }
        }

        function updateMediaControls(hasMedia) {
            document.getElementById('startVideoBtn').disabled = hasMedia;
            document.getElementById('stopVideoBtn').disabled = !hasMedia;
            document.getElementById('toggleAudioBtn').disabled = !hasMedia;
            document.getElementById('toggleVideoBtn').disabled = !hasMedia;
        }

        function enableWebRTCControls(enabled) {
            document.getElementById('leaveBtn').disabled = !enabled;
            document.getElementById('connectBtn').disabled = !enabled || !localStream;
            document.getElementById('disconnectBtn').disabled = !enabled;
            document.getElementById('restartBtn').disabled = !enabled;
        }

        // 오디오/비디오 토글 기능
        function toggleAudio() {
            if (!localStream) return;
            
            const audioTrack = localStream.getAudioTracks()[0];
            if (audioTrack) {
                audioTrack.enabled = !audioTrack.enabled;
                const btn = document.getElementById('toggleAudioBtn');
                btn.textContent = audioTrack.enabled ? '🎤 음소거' : '🔇 음소거 해제';
                log(`음성 ${audioTrack.enabled ? '활성화' : '비활성화'}`, 'info');
            }
        }

        function toggleVideo() {
            if (!localStream) return;
            
            const videoTrack = localStream.getVideoTracks()[0];
            if (videoTrack) {
                videoTrack.enabled = !videoTrack.enabled;
                const btn = document.getElementById('toggleVideoBtn');
                btn.textContent = videoTrack.enabled ? '📷 비디오 끄기' : '📹 비디오 켜기';
                log(`비디오 ${videoTrack.enabled ? '활성화' : '비활성화'}`, 'info');
            }
        }

        function updateVolume() {
            const volume = document.getElementById('volumeSlider').value;
            document.getElementById('volumeValue').textContent = volume;
            
            const remoteVideo = document.getElementById('remoteVideo');
            if (remoteVideo) {
                remoteVideo.volume = volume / 100;
            }
        }

        // WebRTC 연결 함수들 (다중 연결 지원)
        async function connectToRoom() {
            if (!localStream) {
                showError('먼저 비디오를 시작해주세요.');
                return;
            }

            if (!currentRoomCode) {
                showError('방에 먼저 참여해주세요.');
                return;
            }

            log('🔗 WebRTC 연결 시작...', 'info');
            document.getElementById('connectBtn').disabled = true;
            document.getElementById('disconnectBtn').disabled = false;
            
            // 방의 현재 참여자들과 연결
            if (socket) {
                socket.emit('request-room-users', { roomCode: currentRoomCode });
            }
            
            showSuccess('WebRTC 연결을 시작했습니다.');
        }

        function createPeerConnection(targetSocketId) {
            const pc = new RTCPeerConnection({
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ],
                iceCandidatePoolSize: 10
            });

            // 로컬 스트림 추가
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    pc.addTrack(track, localStream);
                });
            }

            // 원격 스트림 처리
            pc.ontrack = (event) => {
                log('📺 원격 스트림 수신됨', 'success');
                const remoteVideo = document.getElementById('remoteVideo');
                if (remoteVideo.srcObject !== event.streams[0]) {
                    remoteVideo.srcObject = event.streams[0];
                    
                    // 해상도 정보 업데이트
                    const videoTrack = event.streams[0].getVideoTracks()[0];
                    if (videoTrack) {
                        videoTrack.onended = () => {
                            document.getElementById('remoteResolution').textContent = '-';
                        };
                    }
                }
            };

            // ICE Candidate 처리
            pc.onicecandidate = (event) => {
                if (event.candidate && socket) {
                    socket.emit('ice-candidate', {
                        candidate: event.candidate,
                        targetSocketId: targetSocketId
                    });
                    log('🧊 ICE Candidate 전송됨', 'debug');
                }
            };

            // 연결 상태 모니터링
            pc.onconnectionstatechange = () => {
                log(`WebRTC 연결 상태: ${pc.connectionState}`, 'info');
                updateConnectionQuality(pc);
                
                if (pc.connectionState === 'connected') {
                    showSuccess('WebRTC 연결이 성공했습니다!');
                    startStatsMonitoring(pc);
                } else if (pc.connectionState === 'failed') {
                    showError('WebRTC 연결에 실패했습니다.');
                }
            };

            peerConnections.set(targetSocketId, pc);
            return pc;
        }

        async function initiateWebRTCConnection(targetSocketId) {
            try {
                const pc = createPeerConnection(targetSocketId);
                
                const offer = await pc.createOffer({
                    offerToReceiveAudio: true,
                    offerToReceiveVideo: true
                });
                
                await pc.setLocalDescription(offer);
                
                socket.emit('offer', {
                    offer: offer,
                    targetSocketId: targetSocketId
                });
                
                log(`📞 Offer 전송됨 to ${targetSocketId}`, 'debug');
            } catch (error) {
                log(`❌ Offer 생성 실패: ${error.message}`, 'error');
            }
        }

        // WebRTC 시그널링 처리
        async function handleReceiveOffer(data) {
            try {
                const pc = createPeerConnection(data.fromSocketId);
                
                await pc.setRemoteDescription(data.offer);
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                
                socket.emit('answer', {
                    answer: answer,
                    targetSocketId: data.fromSocketId
                });
                
                log(`📞 Answer 전송됨 to ${data.fromNickname}`, 'debug');
            } catch (error) {
                log(`❌ Offer 처리 실패: ${error.message}`, 'error');
            }
        }

        async function handleReceiveAnswer(data) {
            const pc = peerConnections.get(data.fromSocketId);
            if (!pc) return;
            
            try {
                await pc.setRemoteDescription(data.answer);
                log(`✅ Answer 처리 완료 from ${data.fromNickname}`, 'debug');
            } catch (error) {
                log(`❌ Answer 처리 실패: ${error.message}`, 'error');
            }
        }

        async function handleReceiveIceCandidate(data) {
            const pc = peerConnections.get(data.fromSocketId);
            if (!pc) return;
            
            try {
                await pc.addIceCandidate(data.candidate);
                log('🧊 ICE Candidate 추가 완료', 'debug');
            } catch (error) {
                log(`❌ ICE Candidate 처리 실패: ${error.message}`, 'error');
            }
        }

        function closePeerConnection(socketId) {
            const pc = peerConnections.get(socketId);
            if (pc) {
                pc.close();
                peerConnections.delete(socketId);
                log(`WebRTC 연결 종료: ${socketId}`, 'info');
            }
        }

        function resetAllConnections() {
            peerConnections.forEach((pc, socketId) => {
                pc.close();
            });
            peerConnections.clear();
            
            const remoteVideo = document.getElementById('remoteVideo');
            remoteVideo.srcObject = null;
            document.getElementById('remoteResolution').textContent = '-';
            
            updateConnectionQuality(null);
            log('모든 WebRTC 연결이 재설정되었습니다.', 'info');
        }

        function disconnectWebRTC() {
            resetAllConnections();
            document.getElementById('connectBtn').disabled = false;
            document.getElementById('disconnectBtn').disabled = true;
            // 채팅 기능 비활성화
            enableChatFeatures(false);
            showSuccess('WebRTC 연결을 해제했습니다.');
        }

        function restartConnection() {
            disconnectWebRTC();
            setTimeout(() => {
                if (currentRoomCode && localStream) {
                    connectToRoom();
                }
            }, 1000);
        }

        // 연결 품질 모니터링
        function updateConnectionQuality(pc) {
            if (!pc) {
                document.getElementById('latency').textContent = '-';
                document.getElementById('packetLoss').textContent = '-';
                document.getElementById('bandwidth').textContent = '-';
                return;
            }

            // WebRTC 통계 수집은 비동기로 처리
            setInterval(() => {
                if (pc.connectionState === 'connected') {
                    getConnectionStats(pc);
                }
            }, 2000);
        }

        async function getConnectionStats(pc) {
            try {
                const stats = await pc.getStats();
                let latency = 0, packetLoss = 0, bandwidth = 0;
                
                stats.forEach(report => {
                    if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                        latency = report.currentRoundTripTime ? Math.round(report.currentRoundTripTime * 1000) : 0;
                    }
                    if (report.type === 'inbound-rtp' && report.mediaType === 'video') {
                        packetLoss = report.packetsLost || 0;
                        bandwidth = Math.round((report.bytesReceived * 8) / 1000) || 0;
                    }
                });

                document.getElementById('latency').textContent = latency;
                document.getElementById('packetLoss').textContent = packetLoss;
                document.getElementById('bandwidth').textContent = bandwidth;
                
                connectionStats = { latency, packetLoss, bandwidth };
            } catch (error) {
                log(`통계 수집 오류: ${error.message}`, 'debug');
            }
        }

        function startStatsMonitoring(pc) {
            log('📊 연결 품질 모니터링 시작', 'info');
            // 이미 updateConnectionQuality에서 처리됨
        }

        // 방 정보 업데이트
        function updateRoomInfo(roomData) {
            const roomInfoElement = document.getElementById('roomInfo');
            const roomDetailsElement = document.getElementById('roomDetails');
            
            roomDetailsElement.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div><strong>🏠 방 코드:</strong> <span style="font-size: 1.2em; color: #007bff;">${roomData.roomCode || currentRoomCode}</span></div>
                    <div><strong>📝 방 이름:</strong> ${roomData.roomName || '알 수 없음'}</div>
                    <div><strong>👥 현재 인원:</strong> ${roomData.currentCapacity || 1}/${roomData.maxCapacity || 4}</div>
                    <div><strong>📊 상태:</strong> <span style="color: #28a745;">${roomData.roomState || 'waiting'}</span></div>
                </div>
            `;
            
            roomInfoElement.style.display = 'block';
        }

        function refreshRoomInfo() {
            if (!currentRoomCode) return;
            
            fetch(`http://localhost:8889/api/rooms/${currentRoomCode}`)
                .then(response => response.json())
                .then(result => {
                    if (result.resultType === 'SUCCESS') {
                        updateRoomInfo(result.success);
                        updateParticipants(result.success.participants);
                        log('방 정보가 새로고침되었습니다.', 'success');
                    }
                })
                .catch(error => {
                    log(`방 정보 새로고침 오류: ${error.message}`, 'error');
                });
        }

        function copyRoomCode() {
            if (!currentRoomCode) return;
            
            navigator.clipboard.writeText(currentRoomCode).then(() => {
                showSuccess('방 코드가 클립보드에 복사되었습니다!');
            }).catch(err => {
                log(`클립보드 복사 실패: ${err}`, 'error');
            });
        }

        // 참여자 목록 업데이트
        function updateParticipants(participants) {
            const participantsElement = document.getElementById('participantsInfo');
            const participantsListElement = document.getElementById('participantsList');
            const participantCountElement = document.getElementById('participantCount');
            
            if (participants && participants.length > 0) {
                participantCountElement.textContent = participants.length;
                
                participantsListElement.innerHTML = participants.map(p => `
                    <div class="participant">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong>${p.nickname}</strong> 
                                <span style="background: ${p.role === 'host' ? '#ff6b6b' : '#4ecdc4'}; 
                                            color: white; padding: 2px 8px; border-radius: 12px; font-size: 0.8em;">
                                    ${p.role === 'host' ? '👑 방장' : '👤 참여자'}
                                </span>
                            </div>
                            <small style="color: #666;">
                                ${new Date(p.joinedAt).toLocaleTimeString()}
                            </small>
                        </div>
                        ${p.preparationStatus ? `
                            <div style="margin-top: 8px; font-size: 0.9em;">
                                <span style="color: ${p.preparationStatus.characterSetup ? '#28a745' : '#dc3545'};">
                                    ${p.preparationStatus.characterSetup ? '✅' : '❌'} 캐릭터 설정
                                </span>
                                <span style="margin-left: 15px; color: ${p.preparationStatus.screenSetup ? '#28a745' : '#dc3545'};">
                                    ${p.preparationStatus.screenSetup ? '✅' : '❌'} 화면 설정
                                </span>
                            </div>
                        ` : ''}
                    </div>
                `).join('');
                
                participantsElement.style.display = 'block';
            } else {
                participantsElement.style.display = 'none';
            }
        }

        function hideRoomInfo() {
            document.getElementById('roomInfo').style.display = 'none';
            document.getElementById('participantsInfo').style.display = 'none';
        }

        // 방 목록 조회
        async function getRoomList() {
            try {
                log('📋 방 목록 조회 중...', 'info');
                
                const response = await fetch('http://localhost:8889/api/rooms?page=1&limit=20');
                const result = await response.json();
                
                if (result.resultType === 'SUCCESS') {
                    displayRoomList(result.success.rooms);
                    document.getElementById('roomListSection').style.display = 'block';
                    log(`방 목록 조회 완료: ${result.success.totalCount}개 방`, 'success');
                } else {
                    throw new Error(result.error?.reason || '방 목록 조회 실패');
                }
            } catch (error) {
                log(`방 목록 조회 오류: ${error.message}`, 'error');
                showError(`방 목록 조회 실패: ${error.message}`);
            }
        }

        function displayRoomList(rooms) {
            const container = document.getElementById('roomListContainer');
            
            if (!rooms || rooms.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666;">현재 활성 방이 없습니다.</p>';
                return;
            }
            
            container.innerHTML = rooms.map(room => `
                <div style="border: 1px solid #ddd; border-radius: 8px; padding: 15px; margin: 10px 0; background: white;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <h4 style="margin: 0; color: #333;">${room.roomName}</h4>
                            <p style="margin: 5px 0; color: #666;">
                                코드: <strong>${room.roomCode}</strong> | 
                                인원: ${room.currentCapacity}/${room.maxCapacity} |
                                상태: ${room.roomState}
                            </p>
                            <small style="color: #999;">
                                방장: ${room.hostGuest?.nickname || '알 수 없음'} | 
                                생성: ${new Date(room.createdAt).toLocaleString()}
                            </small>
                        </div>
                        <button onclick="quickJoinRoom('${room.roomCode}')" 
                                ${room.currentCapacity >= room.maxCapacity ? 'disabled' : ''}>
                            ${room.currentCapacity >= room.maxCapacity ? '만석' : '참여'}
                        </button>
                    </div>
                </div>
            `).join('');
        }

        function quickJoinRoom(roomCode) {
            document.getElementById('joinRoomCode').value = roomCode;
            document.getElementById('guestNickname').value = `게스트${Math.floor(Math.random() * 1000)}`;
            joinRoom();
        }

        function refreshRoomList() {
            getRoomList();
        }

        // 고급 테스트 기능들
        async function testEcho() {
            log('🔊 에코 테스트 시작...', 'info');
            showTestResult('에코 테스트', '음성 입력과 출력을 확인합니다.');
            
            // 간단한 음성 레벨 체크
            if (localStream) {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaStreamSource(localStream);
                const analyser = audioContext.createAnalyser();
                source.connect(analyser);
                
                const dataArray = new Uint8Array(analyser.frequencyBinCount);
                analyser.getByteFrequencyData(dataArray);
                
                const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
                showTestResult('에코 테스트', `평균 음성 레벨: ${Math.round(average)}/255`);
            }
        }

        async function testBandwidth() {
            log('📊 대역폭 테스트 시작...', 'info');
            showTestResult('대역폭 테스트', '네트워크 성능을 측정 중...');
            
            // 현재 연결 상태에서 통계 정보 표시
            setTimeout(() => {
                showTestResult('대역폭 테스트', 
                    `지연시간: ${connectionStats.latency}ms, 패킷손실: ${connectionStats.packetLoss}, 대역폭: ${connectionStats.bandwidth}kbps`);
            }, 2000);
        }

        function simulateNetworkIssue() {
            log('🌐 네트워크 이슈 시뮬레이션...', 'warning');
            showTestResult('네트워크 테스트', '인위적인 지연과 패킷 손실을 시뮬레이션합니다.');
            
            // 실제로는 WebRTC 설정에서 네트워크 조건을 변경해야 함
            setTimeout(() => {
                showTestResult('네트워크 테스트', '시뮬레이션 완료. 연결 상태를 확인해보세요.');
            }, 3000);
        }

        async function recordSession() {
            if (!localStream) {
                showError('녹화하려면 먼저 미디어를 시작해주세요.');
                return;
            }
            
            log('🎬 세션 녹화 시작...', 'info');
            showTestResult('세션 녹화', '브라우저 녹화 기능을 사용합니다.');
            
            try {
                const mediaRecorder = new MediaRecorder(localStream);
                const chunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    chunks.push(event.data);
                };
                
                mediaRecorder.onstop = () => {
                    const blob = new Blob(chunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `session-${Date.now()}.webm`;
                    a.click();
                    showTestResult('세션 녹화', '녹화 완료! 파일이 다운로드됩니다.');
                };
                
                mediaRecorder.start();
                setTimeout(() => mediaRecorder.stop(), 5000); // 5초 녹화
                
            } catch (error) {
                showError(`녹화 실패: ${error.message}`);
            }
        }

        async function shareScreen() {
            try {
                log('🖥️ 화면 공유 시작...', 'info');
                
                const screenStream = await navigator.mediaDevices.getDisplayMedia({ 
                    video: true, 
                    audio: true 
                });
                
                // 로컬 비디오를 화면 공유로 교체
                const localVideo = document.getElementById('localVideo');
                localVideo.srcObject = screenStream;
                
                // 기존 연결이 있다면 트랙 교체
                peerConnections.forEach(pc => {
                    const sender = pc.getSenders().find(s => 
                        s.track && s.track.kind === 'video'
                    );
                    if (sender) {
                        sender.replaceTrack(screenStream.getVideoTracks()[0]);
                    }
                });
                
                showTestResult('화면 공유', '화면 공유가 시작되었습니다.');
                
                // 화면 공유 중단 시 원래 카메라로 복원
                screenStream.getVideoTracks()[0].onended = () => {
                    if (localStream) {
                        localVideo.srcObject = localStream;
                        log('화면 공유가 종료되었습니다.', 'info');
                    }
                };
                
            } catch (error) {
                showError(`화면 공유 실패: ${error.message}`);
            }
        }

        function showTestResult(testName, result) {
            const resultDiv = document.getElementById('testResults');
            const contentDiv = document.getElementById('testResultContent');
            
            contentDiv.innerHTML = `<strong>${testName}:</strong> ${result}`;
            resultDiv.style.display = 'block';
            
            setTimeout(() => {
                resultDiv.style.display = 'none';
            }, 5000);
        }

        // 페이지 로드 시 초기화
        window.onload = function() {
            log('🚀 GameCast WebRTC 고급 테스트 클라이언트 시작', 'success');
            log('브라우저 지원 기능 확인 중...', 'info');
            
            // WebRTC 지원 확인
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                showError('이 브라우저는 WebRTC를 지원하지 않습니다.');
                return;
            }
            
            if (!window.RTCPeerConnection) {
                showError('이 브라우저는 RTCPeerConnection을 지원하지 않습니다.');
                return;
            }
            
            log('✅ WebRTC 지원 확인됨', 'success');
            
            // 랜덤 닉네임 생성
            document.getElementById('guestNickname').value = `사용자${Math.floor(Math.random() * 1000)}`;
            
            // 세션 확인
            checkSession();
            
            // 서버 연결 시작
            connectToServer();
        };

        // 페이지 종료 시 정리
        window.onbeforeunload = function() {
            log('페이지 종료 - 리소스 정리 중...', 'info');
            
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
            
            resetAllConnections();
            
            if (socket) {
                socket.disconnect();
            }
        };

        // 키보드 단축키
        document.addEventListener('keydown', function(event) {
            // Ctrl + Enter: 빠른 방 참여
            if (event.ctrlKey && event.key === 'Enter') {
                event.preventDefault();
                const roomCode = document.getElementById('joinRoomCode').value;
                if (roomCode) {
                    joinRoom();
                } else {
                    createRoom();
                }
            }
            
            // F5 차단하고 방 정보 새로고침
            if (event.key === 'F5') {
                event.preventDefault();
                refreshRoomInfo();
            }
        });

        // 방 코드 입력 시 자동 대문자 변환
        document.getElementById('joinRoomCode').addEventListener('input', function(e) {
            e.target.value = e.target.value.toUpperCase();
        });

        // ========== 채팅 기능 ==========
        
        // 채팅 메시지 전송
        function sendChatMessage() {
            const chatInput = document.getElementById('chatInput');
            const message = chatInput.value.trim();
            
            if (!message) {
                alert('메시지를 입력해주세요.');
                return;
            }
            
            if (!socket || !currentRoomCode) {
                alert('방에 참여한 후 채팅을 사용할 수 있습니다.');
                return;
            }
            
            // 서버로 메시지 전송
            socket.emit('chat-message', {
                roomCode: currentRoomCode,
                message: message,
                timestamp: new Date().toISOString()
            });
            
            // 내 메시지를 채팅창에 추가
            addChatMessage('나', message, true);
            
            // 입력창 초기화
            chatInput.value = '';
        }
        
        // 채팅 메시지를 화면에 추가
        function addChatMessage(sender, message, isOwn = false) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = isOwn ? 'chat-message own' : 'chat-message';
            
            const timestamp = chatSettings.showTimestamp ? 
                new Date().toLocaleTimeString('ko-KR', { hour12: false }) : '';
            
            messageDiv.innerHTML = `
                <div class="message-content">
                    <strong class="sender">${sender}:</strong>
                    <span class="text">${escapeHtml(message)}</span>
                    ${timestamp ? `<small class="timestamp">${timestamp}</small>` : ''}
                </div>
            `;
            
            chatMessages.appendChild(messageDiv);
            
            // 자동 스크롤
            if (chatSettings.autoScroll) {
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }
            
            // 알림음 재생 (본인 메시지가 아닌 경우)
            if (!isOwn && chatSettings.soundNotification) {
                playNotificationSound();
            }
        }
        
        // 채팅 입력 시 엔터키 처리
        function handleChatKeyPress(event) {
            if (event.key === 'Enter') {
                sendChatMessage();
            }
        }
        
        // 채팅창 지우기
        function clearChat() {
            const chatMessages = document.getElementById('chatMessages');
            chatMessages.innerHTML = `
                <div style="text-align: center; color: #666; padding: 20px;">
                    <p>채팅이 시작되면 여기에 메시지가 표시됩니다.</p>
                    <p><small>방에 참여한 후 채팅을 사용할 수 있습니다.</small></p>
                </div>
            `;
        }
        
        // HTML 이스케이프 (XSS 방지)
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // 알림음 재생
        function playNotificationSound() {
            try {
                // Web Audio API를 사용한 간단한 알림음
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.2);
            } catch (error) {
                console.warn('알림음 재생 실패:', error);
            }
        }
        
        // 채팅 설정 토글 함수들
        function toggleTimestamp() {
            chatSettings.showTimestamp = document.getElementById('showTimestamp').checked;
        }
        
        function toggleSoundNotification() {
            chatSettings.soundNotification = document.getElementById('soundNotification').checked;
        }
        
        function toggleAutoScroll() {
            chatSettings.autoScroll = document.getElementById('autoScroll').checked;
        }
        
        // 채팅 기능 활성화/비활성화
        function enableChatFeatures(enabled) {
            document.getElementById('chatInput').disabled = !enabled;
            document.getElementById('sendChatBtn').disabled = !enabled;
            
            if (enabled) {
                addChatMessage('시스템', '채팅이 활성화되었습니다. 메시지를 입력해보세요!', false);
            }
        }
    </script>
    
    <style>
        /* 채팅 메시지 스타일 */
        .chat-message {
            margin-bottom: 12px;
            padding: 10px;
            border-radius: 8px;
            background: #fff;
            border-left: 3px solid #007bff;
            animation: fadeInMessage 0.3s ease-in;
        }
        
        .chat-message.own {
            background: #e7f3ff;
            border-left-color: #28a745;
            margin-left: 20px;
        }
        
        .chat-message .sender {
            color: #007bff;
            font-size: 0.9em;
        }
        
        .chat-message.own .sender {
            color: #28a745;
        }
        
        .chat-message .text {
            color: #333;
            margin-left: 8px;
        }
        
        .chat-message .timestamp {
            float: right;
            color: #666;
            font-size: 0.8em;
        }
        
        @keyframes fadeInMessage {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* 채팅 입력창 포커스 스타일 */
        #chatInput:focus {
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
            outline: none;
        }
        
        /* 스크롤바 스타일링 */
        #chatMessages::-webkit-scrollbar {
            width: 8px;
        }
        
        #chatMessages::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        
        #chatMessages::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 4px;
        }
        
        #chatMessages::-webkit-scrollbar-thumb:hover {
            background: #999;
        }
    </style>

</body>
</html>
